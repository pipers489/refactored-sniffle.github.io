<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Brains & Shotguns ‚Äî Static Web Version</title>
<style>
  :root{
    --bg:#071427; --panel:#0b1220; --muted:#9fb0c0;
    --greenA:#bbf7d0; --greenB:#34d399;
    --yellowA:#fef3c7; --yellowB:#f59e0b;
    --redA:#fecaca; --redB:#f87171;
  }
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,#041028,#071428);color:#eaf4f8;font-family:Inter,system-ui,Arial;padding:18px}
  .app{max-width:1000px;margin:0 auto}
  header{display:flex;justify-content:space-between;align-items:center}
  h1{margin:0;font-size:1.4rem}
  .layout{display:flex;gap:16px;margin-top:12px}
  .left{flex:1}
  .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.03));padding:14px;border-radius:12px}
  .controls{display:flex;gap:8px;margin-top:12px;align-items:center}
  button{padding:10px 14px;border-radius:8px;border:0;background:#10b981;color:#021017;font-weight:700;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:#e6eef6}
  .dice-row{display:flex;gap:10px;margin-top:12px;flex-wrap:wrap}
  .die{width:72px;height:72px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:32px;font-weight:800;color:#071127}
  .die.green{background:linear-gradient(180deg,var(--greenA),var(--greenB));color:#052016}
  .die.yellow{background:linear-gradient(180deg,var(--yellowA),var(--yellowB));color:#3b2700}
  .die.red{background:linear-gradient(180deg,var(--redA),var(--redB));color:#3b0b0b}
  .players{display:flex;flex-direction:column;gap:8px;margin-top:10px}
  .player{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02)}
  .log{margin-top:12px;padding:10px;border-radius:8px;background:rgba(0,0,0,0.06);max-height:360px;overflow:auto}
  .small{font-size:0.88rem;color:var(--muted)}
  .muted{color:#8fa0b0}
  .badge{background:rgba(255,255,255,0.04);padding:6px 8px;border-radius:8px}
  .center{display:flex;align-items:center;gap:8px}
  .stat{font-size:0.95rem}
  .roll-anim{animation: rollShake 420ms ease-in-out}
  @keyframes rollShake {
    0%{ transform: translateY(0) rotate(0deg) scale(1); }
    25%{ transform: translateY(-6px) rotate(-6deg) scale(1.02); }
    50%{ transform: translateY(6px) rotate(6deg) scale(0.99); }
    75%{ transform: translateY(-4px) rotate(-3deg) scale(1.01); }
    100%{ transform: translateY(0) rotate(0deg) scale(1); }
  }
  @media(max-width:860px){ .layout{flex-direction:column} .die{width:56px;height:56px;font-size:24px} }
  footer{margin-top:14px;color:var(--muted);font-size:0.9rem}
</style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>Brains & Shotguns ‚Äî Static Web Version</h1>
        <div class="small">8 green ‚Ä¢ 8 yellow ‚Ä¢ 5 red ‚Äî First to 13 brains</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="newBtn" class="ghost">New Game</button>
        <button id="resetMemory" class="ghost">Reset AI Memory</button>
      </div>
    </header>

    <div class="layout">
      <main class="left card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div class="small">Current player</div>
            <div id="currentPlayer" style="font-weight:800">Player</div>
            <div id="turnInfo" class="small muted">Turn brains: 0 ‚Ä¢ Shotguns: 0</div>
          </div>
          <div style="text-align:right">
            <div class="small">Cup dice left</div>
            <div id="cupCount" class="badge">0</div>
            <div id="discardCount" class="small muted">Discard: 0</div>
          </div>
        </div>

        <div class="dice-row" id="rolledDice" aria-live="polite"></div>

        <div class="controls">
          <button id="rollBtn">Roll</button>
          <button id="stopBtn" class="ghost">Stop & Bank</button>
          <div style="margin-left:auto" class="center">
            <div class="small">AI prob</div><div id="aiProb" class="stat muted">‚Äî</div>
          </div>
        </div>

        <div class="log" id="log" aria-live="polite"></div>
      </main>

      <aside class="card" style="width:320px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>Players</strong></div>
          <div class="small">Dice faces</div>
        </div>

        <div class="players" id="playersList"></div>

        <div style="margin-top:12px">
          <div class="small">AI memory (stored in this browser)</div>
          <div id="memView" style="margin-top:8px" class="muted"></div>
        </div>
      </aside>
    </div>

    <footer>Tip: host this file on tiiny.host ‚Äî no server required.</footer>
  </div>

<script>
/* Client-only Zombie Dice with adaptive AI learning stored in localStorage.
   - 8 green, 8 yellow, 5 red
   - Tracks and displays total scores after each turn
   - AI memory keys: risk_with_2_shotguns, risk_with_1_shotgun, player_risk_tendency, ai_confidence
*/

const DICE = {
  green: ["brain","brain","brain","brain","foot","shot"],
  yellow: ["brain","brain","foot","foot","shot","shot"],
  red: ["brain","foot","foot","shot","shot","shot"]
};
const WIN_SCORE = 13;

// Memory helpers (localStorage)
const MEM_KEY = 'zd_ai_memory_v1';
function loadMemory(){
  try{
    const raw = localStorage.getItem(MEM_KEY);
    if(!raw) return ensureDefaults({});
    const obj = JSON.parse(raw);
    return ensureDefaults(obj);
  } catch(e){ return ensureDefaults({}); }
}
function saveMemory(m){
  localStorage.setItem(MEM_KEY, JSON.stringify(m));
}
function ensureDefaults(mem){
  const defaults = {
    risk_with_2_shotguns: 0.5,
    risk_with_1_shotgun: 0.9,
    player_risk_tendency: 0.5,
    ai_confidence: 0.5
  };
  for(const k in defaults) if(!(k in mem)) mem[k] = defaults[k];
  return mem;
}
function resetMemory(){
  const m = ensureDefaults({});
  saveMemory(m);
  return m;
}

let memory = loadMemory();

// Game state
let state = null;

// Utilities
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} }
function makeCup(){ const c = []; for(let i=0;i<8;i++) c.push('green'); for(let i=0;i<8;i++) c.push('yellow'); for(let i=0;i<5;i++) c.push('red'); shuffle(c); return c; }
function drawFromCup(cup, n){
  if(cup.length < n) return cup.splice(0,cup.length);
  return cup.splice(0,n);
}
function rollDie(color){ const faces = DICE[color]; return faces[Math.floor(Math.random()*faces.length)]; }
function log(msg){ const L = document.getElementById('log'); const time=(new Date()).toLocaleTimeString(); L.insertAdjacentHTML('afterbegin', `<div style="margin-bottom:6px"><span class="muted">${time}</span> ‚Äî ${msg}</div>`); if(L.children.length>200) L.removeChild(L.lastChild); }

function newGame(){
  state = {
    players: [{name:'You', score:0, isAI:false},{name:'Bot', score:0, isAI:true}],
    current: 0,
    cup: makeCup(),
    discard: [],
    footprints: [],
    turnBrains: 0,
    turnShotguns: 0,
    finalRound:false,
    finalTrigger:null
  };
  memory = ensureDefaults(memory);
  saveMemory(memory);
  document.getElementById('rolledDice').innerHTML = '';
  document.getElementById('aiProb').innerText = '‚Äî';
  log('New game started.');
  render();
}

// Render UI
function render(){
  document.getElementById('currentPlayer').innerText = state.players[state.current].name;
  document.getElementById('cupCount').innerText = state.cup.length;
  document.getElementById('discardCount').innerText = state.discard.length;
  document.getElementById('turnInfo').innerText = `Turn brains: ${state.turnBrains} ‚Ä¢ Shotguns: ${state.turnShotguns}`;
  const pl = document.getElementById('playersList'); pl.innerHTML = '';
  state.players.forEach((p, idx)=>{
    const div = document.createElement('div'); div.className='player';
    div.innerHTML = `<div><strong>${p.name}${idx===state.current?' ‚Üê':''}</strong><div class="small">Banked: ${p.score} brains</div></div>
                     <div style="text-align:right"><div class="small">Turn: ${idx===state.current?state.turnBrains:'-'}</div></div>`;
    pl.appendChild(div);
  });
  document.getElementById('memView').innerText = `risk2:${memory.risk_with_2_shotguns.toFixed(2)} risk1:${memory.risk_with_1_shotgun.toFixed(2)} player:${memory.player_risk_tendency.toFixed(2)} ai_conf:${memory.ai_confidence.toFixed(2)}`;
}

// Rolling logic
let rolling=false;
async function playerRoll(){
  if(rolling) return;
  rolling=true;
  // refill if needed
  if(state.cup.length === 0 && state.discard.length>0){
    state.cup = state.discard.splice(0);
    shuffle(state.cup);
    log('Cup recycled from discard.');
  }
  const need = Math.max(0, 3 - state.footprints.length);
  const drawn = drawFromCup(state.cup, need);
  const toRoll = state.footprints.concat(drawn);
  state.footprints = [];
  const rolled = [];
  for(const d of toRoll){
    const face = rollDie(d);
    rolled.push({color:d, face});
    if(face==='brain'){ state.turnBrains++; state.discard.push(d); log(`${state.players[state.current].name} rolled a Brain (${d}).`); }
    else if(face==='shot'){ state.turnShotguns++; state.discard.push(d); log(`${state.players[state.current].name} rolled a Shotgun (${d}).`); }
    else { state.footprints.push(d); log(`${state.players[state.current].name} rolled Footprints (${d}).`); }
  }
  showRolled(rolled);
  render();
  await new Promise(r=>setTimeout(r,420));
  // check bust
  if(state.turnShotguns >= 3){
    // bust
    log(`${state.players[state.current].name} busted with 3 shotguns!`);
    // if AI busted, update memory
    if(state.players[state.current].isAI){
      memory.ai_confidence *= 0.92;
      memory.risk_with_2_shotguns *= 0.95;
      saveMemory(memory);
    } else {
      memory.player_risk_tendency *= 1.05;
      saveMemory(memory);
    }
    // footprints go to discard
    state.discard = state.discard.concat(state.footprints);
    state.footprints = [];
    state.turnBrains = 0;
    state.turnShotguns = 0;
    // show totals
    log(`Total brains ‚Äî You: ${state.players[0].score} ‚Ä¢ Bot: ${state.players[1].score}`);
    // next player
    state.current = (state.current + 1) % state.players.length;
    render();
    // if next is AI, trigger AI loop
    if(state.players[state.current].isAI) setTimeout(botLoop, 600);
  }
  rolling=false;
}

function showRolled(rolled){
  const container = document.getElementById('rolledDice');
  container.innerHTML = '';
  rolled.forEach(r=>{
    const div = document.createElement('div');
    div.className = `die ${r.color} roll-anim`;
    const emoji = r.face==='brain' ? 'üß†' : (r.face==='shot' ? 'üí•' : 'üë£');
    div.textContent = emoji;
    div.title = `${r.color} ‚Ä¢ ${r.face}`;
    container.appendChild(div);
  });
}

// stop and bank
function stopAndBank(){
  // bank current turn
  const p = state.players[state.current];
  p.score += state.turnBrains;
  log(`${p.name} banks ${state.turnBrains} brains (total ${p.score}).`);
  // move footprints to discard
  state.discard = state.discard.concat(state.footprints);
  state.footprints = [];
  state.turnBrains = 0;
  state.turnShotguns = 0;
  // show totals
  log(`Total brains ‚Äî You: ${state.players[0].score} ‚Ä¢ Bot: ${state.players[1].score}`);
  // AI learning updates
  if(p.isAI){
    memory.ai_confidence *= 1.05;
    memory.risk_with_2_shotguns *= 1.02;
    saveMemory(memory);
  } else {
    memory.player_risk_tendency *= 0.98;
    saveMemory(memory);
  }
  // next player
  state.current = (state.current + 1) % state.players.length;
  render();
  if(state.players[state.current].isAI) setTimeout(botLoop, 600);
}

// Bot decision helper
function botShouldContinue(){
  const bot = state.players[state.current];
  const s = state.turnShotguns;
  const b = state.turnBrains;
  let base = 0;
  if(s===0) base = 1.0;
  else if(s===1) base = memory.risk_with_1_shotgun;
  else base = memory.risk_with_2_shotguns;
  let adaptive = base * ((memory.player_risk_tendency + memory.ai_confidence) / 1.5);
  if(bot.score + b >= 12) adaptive += 0.15;
  adaptive = Math.max(0.05, Math.min(0.98, adaptive));
  return {cont: Math.random() < adaptive, prob: adaptive};
}

// Bot loop: roll until bust or decides to stop
async function botLoop(){
  document.getElementById('rollBtn').disabled = true;
  document.getElementById('stopBtn').disabled = true;
  log('ü§ñ Bot starts its turn...');
  while(state.players[state.current].isAI){
    // ensure cup
    if(state.cup.length === 0 && state.discard.length > 0){
      state.cup = state.discard.splice(0);
      shuffle(state.cup);
      log('Cup recycled from discard.');
    }
    // roll once
    await playerRoll();
    // if busted, break
    if(state.turnShotguns >= 3){
      break;
    }
    // decide
    const d = botShouldContinue();
    document.getElementById('aiProb').innerText = (Math.round(d.prob*100) + '%');
    log(`AI decision probability: ${Math.round(d.prob*100)}%`);
    if(!d.cont){
      // stop & bank
      stopAndBank();
      break;
    } else {
      log('ü§ñ Bot chooses to roll again...');
      await new Promise(r=>setTimeout(r,600));
    }
  }
  document.getElementById('rollBtn').disabled = false;
  document.getElementById('stopBtn').disabled = false;
  render();
}

// UI events
document.getElementById('rollBtn').addEventListener('click', ()=> {
  if(state.players[state.current].isAI) return;
  playerRoll();
});
document.getElementById('stopBtn').addEventListener('click', ()=> {
  if(state.players[state.current].isAI) return;
  stopAndBank();
});
document.getElementById('newBtn').addEventListener('click', ()=> newGame());
document.getElementById('resetMemory').addEventListener('click', ()=>{
  memory = resetMemory();
  saveMemory(memory);
  log('AI memory reset.');
  render();
});

// start
newGame();
render();
</script>
</body>
</html>
